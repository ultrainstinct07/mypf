---
title: "E-Voting Prototype"
description: "Early research and mockups for a secure e-voting workflow with cryptographic guarantees."
tags: ["Research", "Security", "Cryptography"]
image: "/images/projects/e-voting.svg"
repoUrl: "https://github.com/kshitiz/e-voting-prototype"
techStack: ["Python", "React", "Cryptography", "Blockchain", "PostgreSQL"]
---

## Overview

This project explores the design and implementation of a secure electronic voting system that balances voter privacy with election integrity. The prototype demonstrates end-to-end verifiable voting using modern cryptographic techniques.

## Core Requirements

### Security Properties
- **Ballot Secrecy**: No one can determine how a specific voter voted
- **Voter Authentication**: Only eligible voters can cast ballots
- **Vote Integrity**: Votes cannot be altered after casting
- **Verifiability**: Voters can verify their vote was counted
- **Coercion Resistance**: Voters cannot prove how they voted to third parties

### Operational Requirements
- **Availability**: System remains operational during voting period
- **Scalability**: Handle thousands of concurrent voters
- **Accessibility**: Support for voters with disabilities
- **Auditability**: Complete audit trail for election officials

## Cryptographic Architecture

### Homomorphic Encryption
The system uses ElGamal encryption to enable vote tallying without decryption:
- Votes are encrypted on the client side
- Encrypted votes can be summed
- Only final tally is decrypted by election officials

### Zero-Knowledge Proofs
Voters generate ZK proofs to demonstrate:
- Their ballot is well-formed (contains valid choices)
- They are eligible to vote
- Without revealing the actual vote

### Threshold Cryptography
Decryption keys are split among multiple trustees:
- No single entity can decrypt votes alone
- Requires cooperation of k-of-n trustees
- Protects against insider attacks

## System Components

### Voter Client
- Web-based interface for ballot marking
- Client-side encryption
- Receipt generation
- Vote verification tools

### Registration Authority
- Voter eligibility verification
- Credential issuance
- Anonymous authentication tokens

### Ballot Box
- Encrypted vote storage
- Duplicate vote prevention
- Public bulletin board for verification

### Tallying System
- Distributed decryption
- Homomorphic vote counting
- Result publication

## Workflow

1. **Registration Phase**
   - Voter proves eligibility
   - Receives blind signature on voting credential
   - Credential unlinkable to identity

2. **Voting Phase**
   - Voter authenticates anonymously
   - Marks ballot in client application
   - Ballot encrypted with public key
   - Generates ZK proof of validity
   - Submits encrypted ballot + proof

3. **Verification Phase**
   - Voter receives receipt with commitment
   - Can check ballot appears on public board
   - Cannot prove ballot contents to others

4. **Tallying Phase**
   - Trustees jointly decrypt tally
   - Public verification of tallying process
   - Results published with cryptographic proofs

## Security Analysis

### Threat Model
- **Malicious Voters**: Attempt to cast invalid votes or vote multiple times
- **Corrupt Officials**: Try to learn individual votes or manipulate results
- **Network Attackers**: Intercept, modify, or replay vote submissions
- **Coercers**: Force voters to reveal their choices

### Mitigations
- Client-side validation and encryption
- Zero-knowledge proofs for ballot correctness
- Threshold decryption prevents single-point compromise
- Anonymous credentials prevent vote buying
- Public bulletin board enables universal verifiability

## Implementation Challenges

### Performance Optimization
- ZK proof generation is computationally expensive
- Solution: Precomputed proof templates, web workers for parallel computation

### User Experience
- Cryptographic operations are complex for average users
- Solution: Simple UI that abstracts technical details

### Browser Compatibility
- WebAssembly for performance-critical crypto operations
- Fallback to JavaScript for older browsers

## Testing & Validation

### Mock Elections
- Conducted 5 test elections with 100+ participants
- Measured performance metrics
- Gathered UX feedback

### Security Audits
- Formal verification of cryptographic protocols
- Penetration testing of system components
- Code review by security researchers

### Performance Metrics
- Average voting time: 45 seconds
- ZK proof generation: 3-5 seconds
- Ballot submission: <1 second
- System handles 1000 concurrent voters

## Limitations & Future Work

### Current Limitations
- Prototype requires technical setup
- No support for complex ballot types (ranked choice, etc.)
- Scalability limited by cryptographic operations
- Coercion resistance is partial

### Future Research
- Post-quantum cryptographic primitives
- Improved coercion resistance mechanisms
- Integration with government identity systems
- Mobile application development
- Accessibility improvements

## Regulatory Considerations

### Compliance
- Research into election law requirements
- Accessibility standards (Section 508, WCAG)
- Data protection regulations (GDPR for European deployments)
- Auditability requirements

### Challenges
- Legal framework for electronic voting varies by jurisdiction
- Voter verifiability vs. secret ballot tension
- Trust in cryptographic systems among general public

## Educational Value

This project provided deep insights into:
- Applied cryptography in real-world systems
- Balancing security and usability
- Formal verification of security properties
- Distributed systems design

## Resources

- [Research Paper](#): Detailed protocol description
- [Demo Video](#): Walkthrough of voting process
- [Threat Model](#): Comprehensive security analysis
- [Source Code](#): MIT licensed implementation

## Acknowledgments

This work builds on decades of research in secure voting systems, particularly the Helios voting system and the work of researchers like Josh Benaloh, Ron Rivest, and David Chaum.
